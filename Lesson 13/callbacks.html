<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

    //Цей код використовує концепцію колбеків (callbacks) у JavaScript. Колбек - це функція, яка передається як аргумент іншій функції і викликається, коли відбувається певна подія або завершується певна операція.

    //1. **Оголошення функції `foo`:**
   function foo(a, b, callback) {
       callback(a, b);
   }

    //У цій функції `foo` передаються три аргументи: `a`, `b` та `callback`. Функція `foo` просто викликає функцію `callback` з переданими їй аргументами `a` і `b`.

    //2. **Виклик функції `foo` з колбеком для додавання:**

   foo(123, 234, (a, b) => {
       console.log(a + b);
   });

    //Тут ми викликаємо функцію `foo` з ар//ументами `123`, `234` та колбеком, який додає ці два числа. Результат (`a + b`) виводиться в консоль.

    //3. **Виклик функції `foo` з колбеком для віднімання:**

   foo(11, 22, (x, y) => console.log(x - y));

    //Тут ми знову викликаємо функцію `foo`, але цього разу з аргументами `11`, `22` та колбеком, який віднімає `y` від `x`. Результат (`x - y`) виводиться в консоль.

    //Отже, загальна ідея використання колбеків у цьому прикладі полягає в тому, що функція `foo` дозволяє вам передавати різні операції чи функції (колбеки) для виконання, і вона викликає ці функції з переданими їй аргументами. Це дозволяє вам легко змінювати поведінку функції `foo`, просто змінюючи переданий колбек.


////////////////////////////////////////////////////////////////
    //  Цей код розширює прототип масиву у JavaScript, додаючи новий метод `customFilter`. Цей метод слугує аналогією для вбудованого методу масиву `filter`, але використовує передану функцію `predicate` для визначення, які елементи повинні бути включені у новий масив результату.
    //  Тут створюється новий метод `customFilter`, який приймає функцію `predicate` як аргумент.

    Array.prototype.customFilter = function (predicate) {
        let res = [];
        for (const item of this) {
    // Якщо поточний елемент відповідає умові, переданій функцією `predicate`, він додається до масиву `res`. Після завершення циклу повертається масив `res`, який містить всі елементи, що задовольняють умову.
            if (predicate(item)) {
                res.push(item);
            }
        }
        return res;

    };

    let customfiler = [11, 22, 33, 44, 55, 66].customFilter((item) => item % 2 === 0);
    console.log(customfiler);

    //Тут викликається метод `customFilter` на масиві `[11, 22, 33, 44, 55, 66]` з функцією `predicate`, яка визначає, що поточний елемент повинен бути парним. Результат виводиться в консоль. У цьому конкретному прикладі `customFilter` фільтрує парні числа, тому `customfiler` буде містити `[22, 44, 66]`.

    //Цей підхід дозволяє створювати власні методи для масивів, які працюють аналогічно вбудованим методам масивів у JavaScript.


</script>
</body>
</html>